\clearpage
\section{Tool availability and implementation}
\label{sec.tool}
\smashpp is implemented in \cpp language and is available at~\cite{web-smashpp}. This tool is able to find and visualize rearrangements in sequences, \fasta and \fastq files; although, it is highly recommended to use sequences as input. In the following sections, we describe installing and running \smashpp.

\subsection{Install}
In order to install \smashpp on Linux, run the following commands:
\begin{code}[style=bash]
git clone https://github.com/smortezah/smashpp.git
cd smashpp
cmake .
make
\end{code}

\subsection{Run}
A reference file and a target file are clearly mandatory to run \smashpp (without visualization). Running
\begin{code}[style=bash]
./smashpp
\end{code}
provides the following guide:
%\vskip2mm
\begin{code}[style=bash]
SYNOPSIS                                                       
  ./smashpp  OPTIONS...  -r REF-FILE  -t TAR-FILE              
                                                               
SAMPLE                                                         
                                                               
DESCRIPTION                                                    
  Mandatory arguments                                          
  -r,  --ref FILE            reference file (Seq/Fasta/Fastq)  
  -t,  --tar FILE            target file    (Seq/Fasta/Fastq)  
                                                               
  Options                                                      
  -v,  --verbose             more information                  
  -l,  --level INT           level of compression: [0, 5]      
  -m,  --min   INT           min segment size: [1, 4294967295] 
  -nr, --no-redun            do NOT compute self complexity    
  -e,  --ent-n FLOAT         Entropy of 'N's: [0.0, 100.0]     
  -n,  --nthr  INT           number of threads: [1, 8]         
  -fs, --filter-scale S|M|L  scale of the filter:              
                             {S|small, M|medium, L|large}      
  -w,  --wsize INT           window size: [1, 4294967295]      
  -wt, --wtype INT/STRING    type of windowing function:       
                             {0|rectangular, 1|hamming, 2|hann,
                             3|blackman, 4|triangular, 5|welch,
                             6|sine, 7|nuttall}                
  -d,  --step   INT          sampling steps                    
  -th, --thresh FLOAT        threshold: [0.0, 20.0]            
  -sp, --save-profile        save profile (*.prf)              
  -sf, --save-filter         save filtered file (*.fil)        
  -sb, --save-seq            save sequence (input: Fasta/Fastq)
  -ss, --save-segment        save segmented files (*-s_i)      
  -sa, --save-all            save profile, filetered and       
                             segmented files                   
  -h,  --help                usage guide                       
  -rm, --ref-model  k,[w,d,]ir,a,g/t,ir,a,g:...                
  -tm, --tar-model  k,[w,d,]ir,a,g/t,ir,a,g:...                
                             parameters of models              
                       (INT) k:  context size                  
                       (INT) w:  width of sketch in log2 form, 
                                 e.g., set 10 for w=2^10=1024  
                       (INT) d:  depth of sketch               
                       (INT) ir: inverted repeat: {0, 1, 2}    
                                 0: regular (not inverted)     
                                 1: inverted, solely           
                                 2: both regular and inverted  
                     (FLOAT) a:  estimator                     
                     (FLOAT) g:  forgetting factor: [0.0, 1.0) 
                       (INT) t:  threshold (no. substitutions)
\end{code}

The arguments ``-r'' and ``-t'' are used to specify the reference and the target, respectively, which are highly recommended to have short names. Level of compression, that is an integer between 0 and 5, can be determined with ``-l''. By setting ``-m'' to an integer value, only those regions in the reference file that are greater than that value can be considered for the compression. Triggering ``-nr'' makes the tool not to perform the reference-free compression (self-complexity computation) part. 

In implementation of the reference-based compression, we have replaced `N' bases in the references and the targets with `A's and `T's, respectively. On reference-free compression, they are replaced with `A's, in both references and targets. If a user tends to replace `N' bases in a sequence with a normal distribution of `A', `C', `G' and `T's, he/she can employ GOOSE toolkit~\cite{web-goose}. Note that we have set the entropy of `N's to 2.0, by default, but it is possible for the user to set them to another value of interest, by ``-e'' option.

Building different finite-context models can be done in the multi-threaded fashion, setting ``-n'' to an integer. To find similar regions in the reference and the target, information profile (obtained by compression) needs to be filtered, of which the scale can be set as S (small), M (medium) or L (large). Size of the window and type of the windowing function, described in~\ref{subsec.software}, can be set by ``-w'' and ``-wt'' options, respectively. Instead of considering the complete profile information, the user is able to make samples of it by steps of which size can be determined by ``-d''.

\subsection{Example}
This section guides, step-by-step, employing \smashpp to find rearrangements.

\subsubsection*{Install \smashpp and provide the required files}
First, we install \smashpp:
\begin{code}[style=bash]
git clone https://github.com/smortezah/smashpp.git
cd smashpp
cmake .
make
\end{code}
Then, we copy \smashpp's binary file into \mono{example/} directory and go to that directory:
\begin{code}[style=bash]
cp smashpp example/
cd example/
\end{code}