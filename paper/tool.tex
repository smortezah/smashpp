\clearpage
\section{Tool availability and implementation} \label{sTool}
\smashpp is implemented in \cpp language and is available at~\cite{web-smashpp}. This tool is able to find rearrangements in sequences, \fasta and \fastq files; although, it is highly recommended to use sequences as input. To work with \smashpp, it should be first installed, and then run. 
% Besides running \smashpp in stand-alone mode, it is possible to compare it with other methods, by means of a set of \bash scripts. 
In the following sections, we describe installing and running \smashpp.


\subsection{Install}
In order to install \smashpp, we run the following commands:
\begin{code}[style=bash]
git clone https://github.com/smortezah/smashpp.git
cd smashpp
cmake .
make
\end{code}


\subsection{Run}
% To run \smashpp, two files are required: a file containing the password (\mono{KEY_FILE}), and the file to be compacted and encrypted (\mono{IN_FILE}). 
Running
\begin{code}[style=bash]
./smashpp
\end{code}
provides the following guide:
%\vskip2mm
\begin{code}[style=bash]
SYNOPSIS
  ./smashpp [OPTIONS]...  -r [REF-FILE] -t [TAR-FILE]

SAMPLE

DESCRIPTION
  Mandatory arguments:
  -r,  --ref FILE            reference file (Seq/Fasta/Fastq)
  -t,  --tar FILE            target file    (Seq/Fasta/Fastq)

  Options:
  -v,  --verbose             more information
  -l,  --level INT           level of compression [0;4]     COMPRESS
  -e,  --ent-n FLOAT         Entropy of 'N's [0.0;100.0]    COMPRESS
  -n,  --nthr  INT           number of threads [1;8]
  -fs, --filter-scale S|M|L  scale of the filter {S|small,    FILTER
                             M|medium, L|large}
  -w,  --wsize INT           window size [1;100000]           FILTER
  -wt, --wtype [0;7]         type of windowing function       FILTER
                             {0|rectangular, 1|hamming, 2|hann,
                             3|blackman, 4|triangular, 5|welch,
                             6|sine, 7|nuttall}
  -d,  --step   INT          sampling steps                   FILTER
  -th, --thresh FLOAT        threshold [0.0;20.0]             FILTER
  -sp, --save-profile        save profile (*.prf)               SAVE
  -sf, --save-filter         save filtered file (*.fil)         SAVE
  -sb, --save-seq            save sequence (input: Fasta/Fastq) SAVE
  -ss, --save-segment        save segmented files (*-sₙ)        SAVE
  -sa, --save-all            save profile, filetered and        SAVE
                             segmented files
  -h,  --help                usage guide 
  -rm, --ref-model [𝜅,[𝑤,𝑑,]ir,$\alpha$,𝛾/𝜏,ir,𝛼,𝛾:...]               MODEL
  -tm, --tar-model [𝜅,[𝑤,𝑑,]ir,𝛼,𝛾/𝜏,ir,𝛼,𝛾:...]               MODEL
                             parameters of models
                       (INT) 𝜅:  context size 
                       (INT) 𝑤:  width of sketch in log2 form, 
                                 e.g., set 10 for w=2^10=1024
                       (INT) 𝑑:  depth of sketch
                             ir: inverted repeat {0, 1, 2}
                                 0: regular (not inverted)
                                 1: inverted, solely
                                 2: both regular and inverted
                     (FLOAT) 𝛼:  estimator
                     (FLOAT) 𝛾:  forgetting factor [0.0;1.0)
                       (INT) 𝜏:  threshold (no. substitutions)
\end{code}

% In the second~line of the \smashpp usage guide, ``\mono{-d}'' option can only be used for \ddion. ``\mono{OUT_FILE}'' is an arbitrary name that specifies the output file and is selected by the user.

% In the fifth and sixth~lines, two samples are shown for \ceion as well as \ddion. In line~5, ``\mono{pass.txt}'' is the file including the password; ``\mono{in.fq}'' is the input file to be compressed and encrypted, in \fastq format; and ``\mono{comp}'' is the output file. In line~6, ``\mono{comp}'' is a file which has previously been \ceed by \smashpp; and ``\mono{orig.fq}'' is the file that keeps the \ddion result. Since \smashpp is a lossless \ceor, \mono{orig.fq} will be exactly the same as \mono{in.fq}.

% Eighth and ninth lines describe the cases in which input files are not of \fasta or \fastq formats. These files can have any other text-based genomic data format, e.g., \vcf, \sam or \bam. In these cases, \smashpp shuffles and encrypts the inputs, but does not compact them. In line 8, ``\mono{in}'' is the input file and ``\mono{enc}'' is shuffled and encrypted file. In line 9, ``\mono{enc}'' is the file that has been previously encrypted by \smashpp and ``\mono{orig}'' is unshuffled and decrypted file.

% There are two methods to make a ``\mono{KEY_FILE}'' and then pass to the ``\mono{-k}'' or ``\mono{--key}'' flags, at line~18: either saving a raw password in a file, or employing the ``keygen'' program, which is provided to generate a strong password. The second method is highly recommended.

% For the first method, the following commands can be used to save a raw password in a file and then pass it to \smashpp. In this case, ``\mono{Such a strong password!}'' is our raw password and ``\mono{pass.txt}'' is the file we save our password in it. To save a password in a file, a text editor can also be used:
% \begin{code}[style=bash]
% echo "Such a strong password!" > pass.txt
% ./cryfa -k pass.txt IN_FILE > OUT_FILE
% \end{code}
% Note, the password must include at least 8 characters. Although, employing this method is not recommended, but if you tend to use it, it would be a better practice to choose a ``strong password''.

% A strong password:
% \begin{itemize}
% \item has at least 12 characters
% \item includes lowercase letters (\mono{a}--\mono{z}), uppercase letters (\mono{A}--\mono{Z}), digits (\mono{0}--\mono{9}) and symbols (e.g., \mono{\#}, \mono{\%}, \mono{\$})
% \item is not a character repetition (e.g., \mono{zzzzzz}), keyboard pattern (e.g., \mono{qwerty}) or digit sequences (e.g., \mono{123456})
% \end{itemize}

% The second method to make a key file is using the ``keygen'' program, which 
% automatically provides with a strong password. Running
% \begin{code}[style=bash]
% ./keygen
% \end{code}
% the following message appears:
% \begin{code}[style=bash]
% Enter a password, then press `Enter':
% \end{code}
% After typing a raw password, e.g., ``\mono{A keygen raw pass!}'', and pressing ``Enter'', the following message appears:
% \begin{code}[style=bash]
% Enter a file name to save the generated key, then press `Enter':
% \end{code}
% The automatically generated strong password will be saved in the file that you specify its name, e.g,.~``\mono{key.txt}'', in this step. Note, the ``keygen'' program needs an initial raw password, which is not required to be strong itself, to generate a strong password. Afterward, you can use the following command to pass the key file, in this case ``\mono{key.txt}'', to \smashpp:
% \begin{code}[style=bash]
% ./cryfa -k key.txt IN_FILE > OUT_FILE
% \end{code}

% With ``\mono{-f}'' or ``\mono{--force}'' flag, at line~30 of the usage guide, the input file is forced to be considered as a non-\fasta/\fastq file; this way, \smashpp does not compact that file and exclusively shuffles and encrypts it. Note, even if the input is of \fasta/\fastq format, it is again considered as a non-\fasta/\fastq file, therefore, compaction will be ignored, but shuffling and encryption will be performed.

% To avoid low data complexity attacks, \smashpp shuffles the input, by default. However, it is possible to disable shuffling, using ``\mono{-s}'' option, as shown in line~40 of the usage guide. Note, this option should only be used in the encryption side, since \smashpp automatically detects in the decryption side whether or not the file had been shuffled.


% \subsection{Example}
% This section guides, in a step-by-step manner, employing \smashpp to \ce as well as \dd a sample file.

% \subsubsection*{Install \smashpp and provide the required files}
% First, we install \smashpp:
% \begin{code}[style=bash]
% git clone https://github.com/pratas/cryfa.git
% cd cryfa
% cmake .
% make
% \end{code}
% Then, we copy \smashpp's binary file into \mono{example/} directory and go to that directory:
% \begin{code}[style=bash]
% cp cryfa example/
% cd example/
% \end{code}

% In order to run \smashpp, we need a file to be \ceed/encrypted as well as a file containing the password. In the \mono{example/} directory, the file ``\mono{in.fq}'' is provided, which would be \ceed. The contents of \mono{in.fq} is
% \begin{code}[style=bash]
% @SRR707196.1 HWI-ST896:317:C1HAMACXX:7:1101:1338:2148/1
% TCGAGAGCTCATTGATGCTCTGACAGCTGAAATTCTTCGTCTTAGAGAAGAAAACGCTGCTACACAGGTACTCAG
% +
% 4=DDFFFHHHHHJJJJJJJJJJJJJJJJJJJJJJJJJJJHHIIJIJJJJJIJJJJJJJJJJJJJJHHH=CEFFFF
% @SRR707196.2 HWI-ST896:317:C1HAMACXX:7:1101:1492:2234/1
% GATAAAGATCAAATAAGAGCCTCAGGGGACTGAATCCAACGGGAATATTAGAGTCCTACAGGGAGCCCCCAACCC
% +
% CCCFFFFFHGHHHIJJJJJJJJIJJJJJJJJJJJIJJJJJJJJIJIJJJIJJJFHIJJJJJIGFHFFFFDDDDDD
% \end{code}
% To provide a password file for running \smashpp, we run keygen program:
% \begin{code}[style=bash]
% ./keygen
% \end{code}
% The following message appears:
% \begin{code}[style=bash]
% Enter a password, then press `Enter':
% \end{code}
% We enter ``\mono{A raw password!}'' or any other arbitrary raw password and press ``Enter''. Then, the following message appears:
% \begin{code}[style=bash]
% Enter a file name to save the generated key, then press `Enter':
% \end{code}
% We choose ``\mono{pass.txt}'' for the key file name and press ``Enter''.


% \subsubsection*{\Ce}
% In order to \ce the file \mono{in.fq} and save the output in the file ``\mono{comp}'', we type
% \begin{code}[style=bash]
% ./cryfa -k pass.txt in.fq > comp
% \end{code}
% ``\mono{-k}'' option is used to specify the key file, i.e. \mono{pass.txt}.

% \subsubsection*{\Dd}
% To \dd the file \mono{comp} and save the output in the file ``\mono{orig.fq}'', we write
% \begin{code}[style=bash]
% ./cryfa -k pass.txt -d comp > orig.fq
% \end{code}
% ``\mono{-d}'' option specifies the \ddion operation.

% Note that, to \dd a file using \smashpp, it needs to be already \ceed by \smashpp. Additionally, since \smashpp is a lossless \ceor, \mono{orig.fq} will be exactly the same as \mono{in.fq}. This can be checked by
% \begin{code}[style=bash]
% cmp in.fq orig.fq
% \end{code}

% \smashpp has this capability to ignore compaction and/or shuffling phases. In the following, it is described how to perform that.

% \subsubsection*{Shuffle, encrypt, decrypt and unshuffle}
% In the case we do not tend to compact a \fasta/\fastq file and only want to shuffle and encrypt it, \mono{-f}~flag can be used:
% \begin{code}[style=bash]
% ./cryfa -k pass.txt -f in.fq > enc
% \end{code}
% For decryption and unshuffling, the following command is used, which is the same as if the original file was compacted:
% \begin{code}[style=bash]
% ./cryfa -k pass.txt -d enc > orig.fq
% \end{code}

% \subsubsection*{Encrypt and decrypt}
% In the case we exclusively need to encrypt and then decrypt a file, we can type the following:
% \begin{code}[style=bash]
% ./cryfa -k pass.txt -f -s in.fq > enc
% ./cryfa -k pass.txt -d enc > orig.fq
% \end{code}


% \subsection{Compare with other methods}
% To make a comparison between \smashpp and other methods, including \gzip, \bzip, \mfcompress, \deliminate, \fqzcomp, \quip, \dsrc, \fqc and \aescrypt, a set of \bash scripts are provided. These scripts make it possible to download the datasets, install the dependencies, install the compression and encryption tools, run these tools and finally, save the results in a number of tables. To perform each of these operations, a set of parameters should be set in \mono{run.sh} script, which can be found in the main directory of \smashpp tool. These parameters are described in the following sections. The value of each parameter must be set to 1 to activate, and 0 to deactivate.

% \subsubsection*{Datasets}
% Among the parameters for getting the datasets, if \mono{GET_DATASET} is 0, no dataset will be downloaded. Otherwise, if \mono{GET_DATASET} is 1, the datasets associated with the parameters with the value 1 will be downloaded. For example, with the following set of values, only \fasta datasets will be downloaded. Note, storing all datasets needs 54~GB free disk space.
% \begin{code}[style=bash]
% GET_DATASET=1               # 54 GB free disk space
%     DL_HUMAN_FA=1           # Download Human             (FASTA) -- 3.1  GB
%     DL_VIRUSES_FA=1         # Download Viruses           (FASTA) -- 0.3  GB
%     GEN_SYNTH_FA=1          # Generate synthetic dataset (FASTA) -- 2.8  GB
%     DL_HUMAN_FQ=0           # Download Human             (FASTQ) -- 27.0 GB
%     DL_DENISOVA_FQ=0        # Download Denisova          (FASTQ) -- 2.9  GB
%     GEN_SYNTH_FQ=0          # Generate synthetic dataset (FASTQ) -- 6.1  GB
%     DL_DENISOVA_VCF=0       # Download Denisova          (VCF)   -- 6.3  GB
%     DL_NEANDERTHAL_VCF=0    # Download Neanderthal       (VCF)   -- 0.8  GB
%     DL_HUMAN_SAM=0          # Download Human             (SAM)   -- 0.5  GB
%     DL_NEANDERTHAL_SAM=0    # Download Neanderthal       (SAM)   -- 1.5  GB
%     DL_HUMAN_BAM=0          # Download Human             (BAM)   -- 0.6  GB
%     DL_NEANDERTHAL_BAM=0    # Download Neanderthal       (BAM)   -- 1.3  GB
% \end{code}

% \subsubsection*{Dependencies}
% To install dependencies of different methods, the following parameters can be set. Note, executables of the methods are provided in the repository and \szip and \cmake are enough to run the methods.
% \begin{code}[style=bash]
% INSTALL_DEPENDENCIES=1
%     INS_7ZIP=1          # 7zip
%     INS_CMAKE=1         # Cmake
%     INS_BOOST=0         # Boost
%     INS_CURL=0          # Curl
%     INS_VALGRIND=0      # Valgrind
%     INS_ZLIB=0          # Zlib
%     INS_SAMTOOLS=0      # Samtools
% \end{code}

% \subsubsection*{Install methods}
% By setting the following parameters, the methods can be installed. However, since the executables of all methods but \smashpp is available at \mono{progs/} directory, it is only required to install \smashpp.
% \begin{code}[style=bash]
% INSTALL_METHODS=1
%     # FASTA/FASTQ/VCF/SAM/BAM
%     INS_CRYFA=1         # Cryfa
%     # FASTA
%     INS_MFCOMPRESS=0    # MFCompress
%     INS_DELIMINATE=0    # DELIMINATE
%     # FASTQ
%     INS_FQZCOMP=0       # fqzcomp
%     INS_QUIP=0          # Quip
%     INS_DSRC=0          # DSRC
%     INS_FQC=0           # FQC
%     # Encryption -- FASTA/FASTQ/VCF/SAM/BAM
%     INS_AESCRYPT=0      # AES Crypt
% \end{code}

% \subsubsection*{Run \smashpp}
% The following setting can be used to run \smashpp on all \fasta, \fastq, \vcf, \sam and \bam datasets, then save the results at \mono{result/} directory. The results include \cratio, memory usage and elapsed time for \ceing and \dding the datasets. Note, running \smashpp on all datasets needs 100~GB free disk~space in order to store compressed files along with reconstructed datasets, which will be obtained from \ddion phase. For debugging purpose, the reconstructed files are stored at \mono{progs/cryfa/} directory to enable user to perform a comparison, individually, between these files and the original datasets.
% \begin{code}[style=bash]
% RUN_METHODS_COMP=1      # 100 GB free disk space
%     # FASTA
%     RUN_CRYFA_FA=1      # Cryfa
%     # FASTQ
%     RUN_CRYFA_FQ=1      # Cryfa
%     # VCF
%     RUN_CRYFA_VCF=0     # Cryfa
%     # SAM
%     RUN_CRYFA_SAM=0     # Cryfa
%     # BAM
%     RUN_CRYFA_BAM=0     # Cryfa
%     # Results
%     RESULTS_COMP=1
% \end{code}

% \subsubsection*{Run \ceion methods}
% Setting the following parameters, the methods will be carried out on all datasets. In order to \ce a dataset, it is first compressed by a compression method, then encrypted by \aescrypt. Also, to \dd a dataset, it is first decrypted by \aescrypt, then decompressed by a compression method. Note that, running \fasta and \fastq methods needs 60~GB free disk~space. A portion of this space is used to store the reconstructed datasets, which are obtained from \ddion phase. This is helpful when a method cannot compress a file, losslessly. In this case, the user will be able to find differences of the reconstructed file and the original dataset.
% \begin{code}[style=bash]
% RUN_METHODS_COMP_ENC=1
%     # Fasta -- 10 GB free disk space
%     RUN_GZIP_FA_AESCRYPT=1       # gzip       + AES Crypt
%     RUN_BZIP2_FA_AESCRYPT=1      # bzip2      + AES Crypt
%     RUN_MFCOMPRESS_AESCRYPT=1    # MFCompress + AES Crypt
%     RUN_DELIMINATE_AESCRYPT=1    # DELIMINATE + AES Crypt
%     # Fastq -- 50 GB free disk space
%     RUN_GZIP_FQ_AESCRYPT=1       # gzip       + AES Crypt
%     RUN_BZIP2_FQ_AESCRYPT=1      # bzip2      + AES Crypt
%     RUN_FQZCOMP_AESCRYPT=1       # fqzcomp    + AES Crypt
%     RUN_QUIP_AESCRYPT=1          # Quip       + AES Crypt
%     RUN_DSRC_AESCRYPT=1          # DSRC       + AES Crypt
%     RUN_FQC_AESCRYPT=1           # FQC        + AES Crypt
%     # Results
%     RESULTS_COMP_ENC=1
% \end{code}

% \subsubsection*{Run encryption methods}
% To run \aescrypt, a \generalPur encryption method, the following setting can be used. Note, running this method on all \fasta, \fastq, \vcf, \sam and \bam datasets needs 110~GB free disk~space.
% \begin{code}[style=bash]
% RUN_METHODS_ENC=1       # 110 GB free disk space
%     RUN_AESCRYPT=1      # AES Crypt
%     # Results
%     RESULTS_ENC=1
% \end{code}


% \subsection{Run with different number of threads} \label{ssThreads}
% The followings can be set to run \smashpp with a different number of threads on a single dataset. In this example, \smashpp will be carried out on \mono{viruses.fasta} dataset with $1, 2, \ldots, 8$~threads, then the results will be saved at \mono{result/} directory. To specify the path of the dataset, \mono{CRYFA_THR_DATASET}, the main directory of \smashpp should be considered as the origin.
% \begin{code}[style=bash]
% RUN_CRYFA_THREADS=1
%     MAX_N_THR=8         # Max number of threads
%     CRYFA_THR_DATASET="dataset/FA/V/viruses.fasta"
%     #CRYFA_THR_DATASET="dataset/FQ/DS/DS-B1088_SR.fastq"
%     # Run
%     RUN_CRYFA_THR=1
%     # Results
%     RESULTS_CRYFA_THR=1
% \end{code}


% \subsection{Explore redundancy} \label{ssRedundancy}
% This part is provided to evaluate how different methods explore redundancy in genomic sequences. For this purpose, \mono{RUN_REDUNDANCY} should be set to 1. The NC (see Note~\ref{ssRedundancy}) results of running \smashpp as well as \deliminate and \mfcompress, as two Fasta file compressors, on a collection of archaea, bacteria, fungi, plants and viruses datasets will be saved at \mono{result/} directory. Note, the datasets need 12~GB free disk space.
% \begin{code}[style=bash]
% RUN_REDUNDANCY=1        # Cryfa, DELIMINATE, MFCompress
%     # Dataset (Fasta) -- archaea, bacteria, fungi, plants, viruses
%     GET_DATASET_REDUN=1 # 12 GB free disk space
%     # Run & Results
%     RUN_RES_REDUN=1
% \end{code}